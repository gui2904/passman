#!/usr/bin/env python3

import json
import sys
import shutil
import subprocess
import string
import secrets
import argparse
import getpass
from cryptography.fernet import Fernet
from pathlib import Path

# Defining Paths
APP_DIR = Path.home() / ".config" / "passman"
KEY_FILE = APP_DIR / "secret.key"
CREDENTIALS_FILE = APP_DIR / "credentials.json"

def ensure_app_dir():
    APP_DIR.mkdir(mode=0o700, parents=True, exist_ok=True)

# Function to generate random pass
def generate_password(
    length: int = 16,
    use_lower: bool = True,
    use_upper: bool = True,
    use_digits: bool = True,
    use_special: bool = True,

    ) -> str:
    if length < 4:
        raise ValueError("Password length must be at least 4")

    pools = []
    guaranteed = []

    if use_lower:
        pools.append(string.ascii_lowercase)
        guaranteed.append(secrets.choice(string.ascii_lowercase))
    if use_upper:
        pools.append(string.ascii_uppercase)
        guaranteed.append(secrets.choice(string.ascii_uppercase))
    if use_digits:
        pools.append(string.digits)
        guaranteed.append(secrets.choice(string.digits))
    if use_special:
        pools.append(string.punctuation)
        guaranteed.append(secrets.choice(string.punctuation))

    if not pools:
        raise ValueError("At least one character set must be enabled")

    pool = "".join(pools)
    remaining = length - len(guaranteed)

    password_chars = guaranteed + [
        secrets.choice(pool) for _ in range(remaining)
    ]

    secrets.SystemRandom().shuffle(password_chars)
    return "".join(password_chars)

# Encryption and Decryption Functions
def generate_key():
    return Fernet.generate_key()

def load_key():
    ensure_app_dir()
    if not KEY_FILE.exists():
        key = Fernet.generate_key()
        KEY_FILE.write_bytes(key)
        KEY_FILE.chmod(0o600)
    return KEY_FILE.read_bytes()

def encrypt_message(message):
    key = load_key()
    f = Fernet(key)
    return f.encrypt(message.encode("utf-8")).decode("utf-8")

def decrypt_message(encrypted_message: str) -> str:
    key = load_key()
    f = Fernet(key)
    return f.decrypt(encrypted_message.encode("utf-8")).decode("utf-8")

# Password Manager Functions
def load_credentials():
    ensure_app_dir()
    if not CREDENTIALS_FILE.exists():
        return {}
    try:
        return json.loads(CREDENTIALS_FILE.read_text())
    except json.JSONDecodeError:
        print("credentials.json is corrupted.")
        return {}

def save_credentials(credentials):
    ensure_app_dir()
    tmp = CREDENTIALS_FILE.with_suffix(".tmp")
    tmp.write_text(json.dumps(credentials, indent=2, sort_keys=True))
    tmp.chmod(0o600)
    tmp.replace(CREDENTIALS_FILE)
    CREDENTIALS_FILE.chmod(0o600)

def add_credential(name, username, password, force=False):
    credentials = load_credentials()
    if name in credentials and not force:
        print(f"Credential '{name}' already exists. Use --force to overwrite.")
        return
    encrypted_password = encrypt_message(password)
    credentials[name] = {"username": username, "password": encrypted_password}
    save_credentials(credentials)
    print("Credential added successfully.")

def view_credentials(name):
    credentials = load_credentials()
    if name in credentials:
        user_info = credentials[name]
        decrypted_password = decrypt_message(user_info["password"])
        print(f"Name: {name}")
        print(f"Username: {user_info['username']}")
        print(f"Password: {decrypted_password}")
    else:
        print("Credential not found.")

def list_credentials():
    credentials = load_credentials()
    if not credentials:
        print("No credentials saved.")
        return
    for name in sorted(credentials.keys()):
        print(name)

def edit_credential(name, new_username=None, new_password=None):
    credentials = load_credentials()
    if name in credentials:
        if new_username:
            credentials[name]["username"] = new_username
        if new_password:
            credentials[name]["password"] = encrypt_message(new_password)
        save_credentials(credentials)
        print("Credential updated successfully.")
    else:
        print("Credential not found.")

def rename_credential(old_name, new_name, force=False):
    credentials = load_credentials()
    if old_name not in credentials:
        print("Credential not found.")
        return
    if new_name in credentials and not force:
        print(f"'{new_name}' already exists. Use --force to overwrite.")
        return
    credentials[new_name] = credentials.pop(old_name)
    save_credentials(credentials)
    print("Credential renamed successfully.")

def delete_credentials(name, yes=False):
    credentials = load_credentials()
    if name not in credentials:
        print("Credential not found.")
        return
    if not yes:
        confirm = input(f"Delete '{name}'? (y/N): ").strip().lower()
        if confirm != "y":
            print("Cancelled.")
            return
    del credentials[name]
    save_credentials(credentials)
    print("Credential deleted successfully.")

# Function to copy password to clipboard.    
def copy_to_clipboard(text: str) -> bool:
    try:
        if shutil.which("wl-copy"):
            subprocess.run(["wl-copy"], input=text, text=True, check=True)
            return True
        if shutil.which("xclip"):
            subprocess.run(["xclip", "-selection", "clipboard"], input=text, text=True, check=True)
            return True
        return False
    except subprocess.CalledProcessError:
        return False

# Command-Line Interface
def main():
    parser = argparse.ArgumentParser(description="Simple Password Manager")
    parser.add_argument("command", choices=["add", "view", "edit", "list", "delete", "rename", "gen"], help="Command to run")
    parser.add_argument("name", nargs="?",help="Name of the credential")
    parser.add_argument("--new-name", help="New name for rename")
    parser.add_argument("--username", help="Username for the credential")
    parser.add_argument("--prompt", action="store_true", help="Prompt for password (won't be shown or saved in shell history)")
    parser.add_argument("--force", action="store_true", help="Overwrite if destination exists")
    parser.add_argument("--yes", action="store_true", help="Assume yes (delete without prompt)")
    parser.add_argument("--length", type=int, default=16, help="Generated password length") 
    parser.add_argument("--copy", action="store_true", help="Copy password to clipboard")
    parser.add_argument("--print", dest="do_print", action="store_true", help="Print password to stdout (careful)")
    args = parser.parse_args()

    if args.command == "list":
        list_credentials()

    elif args.command == "add":
        if not args.name or not args.username:
            print("Name and --username are required to add a credential.")
            return

        # 1) Determine password first (prompt or generate)
        if args.prompt:
            p1 = getpass.getpass("Password: ")
            p2 = getpass.getpass("Confirm: ")
            if p1 != p2:
                print("Passwords do not match.")
                return
            if not p1:
                print("Password cannot be empty.")
                return
            password = p1
        else:
            password = generate_password(length=args.length)

        # 2) Then optinal clipboard/print
        if args.copy:
            if copy_to_clipboard(password):
                print("Password copied to clipboard.")
            else:
                print("No clipboard tool found (install wl-clipboard or xclip.)")

        if args.do_print:
            print(password)

         # 3) Finally store it  
        add_credential(args.name, args.username, password, force=args.force)

    elif args.command == "view":
        if not args.name:
            print("Name is required for view.")
            return
        view_credentials(args.name)

    elif args.command == "edit":
        if not args.name:
            print("Name is required for edit.")
            return
        new_password = None
        if args.prompt:
            p1 = getpass.getpass("New password: ")
            p2 = getpass.getpass("Confirm: ")
            if p1 != p2:
                print("Passwords do not match.")
                return
            if not p1:
                print("Password cannot be empty.")
                return
            new_password = p1
        edit_credential(args.name, args.username, new_password)

    elif args.command == "delete":
        if not args.name:
            print("Name is required for delete.")
            return
        delete_credentials(args.name, yes=args.yes)

    elif args.command == "rename":
        if not args.name or not args.new_name:
            print("Rename requires: old name and --new-name")
            return
        rename_credential(args.name, args.new_name, force=args.force)

    elif args.command == "gen":
        pw = generate_password(length=args.length)
        if args.copy:
            if copy_to_clipboard(pw):
                print("Password copied to clipboard")
            else:
                print("No clipboard tool found (install wl-clipboard or xclip).")
        if args.do_print or not args.copy:
            print(pw)
        return

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nCancelled.")
        sys.exit(130)
    except BrokenPipeError:
        sys.exit(0)
